Introduction
============
This package provides Python *.py files for measuring and calculating the gain (Cij - contains the antenna's gain and the environmental attenuation) between two nodes located in a VESNA-based wireless sensor network that uses ALH protocol in order to communicate.

Before using this package, please install VESNA ALH Tools and Python bindings for VESNA spectrum sensor application. In order to do this, please follow the steps described here:

* 1) Installation of VESNA ALH Tools
(see its own README file for installation instructions - Tomaz Solc)
* https://github.com/avian2/vesna-alh-tools

* 2) Installation of Python bindings for VESNA spectrum application 
(see its own README file for installation instructions - Tomaz Solc)
* https://github.com/sensorlab/vesna-spectrum-sensor

This package contains the following .py files:
* **1) node.py**
* used to configure the nodes (transmitter or receiver), generate a signal and sense the spectrum
* used to check the functionality of the nodes
* **2) gainCalculations.py**
* used for measuring the channel gain between two VESNA nodes
* **3) kalmanImplementation.py**
* uses the PyKalman module
* used for predicting the channel gain
* **4) myQueue.py**
* used for forming a queue with a given size
* used as a history of channel gain measurements for the Kalman predictor
* **5) plot.py**
* used for plotting the channel gains


Methodology for measuring the gain between two nodes
====================================================

We consider a system formed by a single transmitter-receiver pair: TXi - RXj

	
			+------+          +------+
			| TXi  | --Cij--> | RXj  |
			+------+          +------+ 
			   |		     |
		 	   |		     |
		 	  _|_		    _|_

		Fig.1 Cij - is the channel gain between 
	            	    transmitter i and receiver j

We define Cij = (PRXj - Pnoise) / (PTXi) where:

	PRXj [W] is the power received at receiver j
	PTXi [W] is the power transmitted by transmitter i
	Pnoise [W] is the noise power.

		   +------+                          +------+
		   | TXi  | ----------Cij----------> | RXj  |
		   +------+                          +------+ 

	Fig.2 Ideal situation, where in the system there is no noise power

				Cij = PRXj / PTXi

		+------+                   +-----+        +------+
		| TXi  | ----------Cij-----| ADD |------> | RXj  |
		+------+                   +-----+        +------+ 
					                  ^
					                  |
					                  |
					              +-------+
					              | noise |
					              +-------+

	Fig.3 Real situation, where the noise signal adds to the transmitted signal

				Cij = (PRXj - Pnoise) / (PTXi)

Steps to follow in order to measure the gain between two nodes:
===============================================================

1. Measure the noise power. No signal should be generated by the transmitter during this step.
1. Generate a signal.
1. Measure the received signal
1. Calculate Cij gain

gainCalculations.py
===================

gainCalculations.py contains class GainCalculations with the following methods:

* **1) calculateInstantGain(coor_id,tx_id,rx_id,measuring_freq,transmitting_duration)**
* defines one transmission node and one reception node
* sets the measurement frequency, transmitting power in [dBm], transmission duration in [s] and the sensing duration in seconds
* configures the reception node for sensing
* starts the sensing on the reception node
* measures the noise power
* configures the transmission noise for signal generation
* starts the transmission
* measures the received signal
* returns the calculated Cij gain
* **2) getAverageDataMeasurementsFromFile(coor_id,node_id)**
* reads the data from file (data was stored in a file by the sensing method)
* it averages the power at every frequency
* returns a list with the following structure:[frequency,averaged power for one specific frequency]
* **3) getAverageGain(coord_id,tx_id,rx_id)**
* reads the data from file
* it averages all the gain data in that file
* **4) printResultsInAFile(results_list, coor_id, tx_id, rx_id)**
* appends results_list in a file
* the results_list contains :[gain,received_power[w],noise_power[w],transmitted_power[w], date]
* **5) plotGains(coor_id,tx_id,rx_id)**
* opens the file containing the gain measurements
* plots the gains Cij(t)
* **6) getMinMaxGain(coord_id,tx_id,rx_id)**
* reads the data from file and it returns the maximum and the minimum measured gain
* **7) getMinMaxNoise(coord_id,tx_id,rx_id)**
* reads the data from file and it returns the maximum and the minimum measured noise
* **8) getMostRecentGainMeasurments(coord_id,tx_id,rx_id,number)**
* returns a list a number of "number" last channel gain measurements made
* **9) getUpdatedPredictedGain(coord_id,tx_id,rx_id,number)**
* this method will take a new channel gain measurement (update) and based on number measurements done previously and saved in a .dat file will predict the next gain
* **10) getStandardDeviation(coord_id,tx_id,rx_id)**
* returns the standard deviation of the channel gain measurements stored in a .dat file
* **11) plotAllGainsWithinCoordinator(coord_id)**
* plots all the gain within the coordinator
